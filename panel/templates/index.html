<!doctype html>
<html lang="de">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>agent-control-surface (acs)</title>
    <style>
      :root {
        color-scheme: light dark;
      }
      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        margin: 16px;
        line-height: 1.4;
      }
      h1 {
        margin-bottom: 8px;
      }
      label {
        font-weight: 600;
      }
      .row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-bottom: 8px;
      }
      button {
        padding: 10px 14px;
        font-size: 16px;
      }
      input,
      select,
      textarea {
        padding: 10px;
        font-size: 16px;
      }
      textarea {
        width: 100%;
        min-height: 220px;
      }
      pre {
        white-space: pre-wrap;
        word-break: break-word;
        padding: 12px;
        background: #f3f3f3;
        border-radius: 6px;
        max-height: 360px;
        overflow: auto;
      }
      .section {
        margin-top: 24px;
      }
      .small {
        font-size: 14px;
        opacity: 0.8;
      }
      .status {
        font-weight: 600;
        margin-top: 8px;
      }
      .status.success {
        color: #2e7d32;
      }
      .status.warn {
        color: #b36b00;
      }
      .status.error {
        color: #c62828;
      }
    </style>
  </head>
  <body>
    <h1>agent-control-surface (acs)</h1>
    <p class="small">Local-only Control Surface for Jules & Git.</p>

    <label for="repo">Repo</label>
    <select id="repo">
      <option value="">-- Repo auswählen --</option>
      {% for repo in repos %}
      <option value="{{ repo.key }}">{{ repo.display }}</option>
      {% endfor %}
    </select>

    <section class="section">
      <h2>Sessions</h2>
      <div class="row">
        <input id="title" placeholder="New session title" style="min-width: 260px" />
        <button onclick="newSession()" data-repo-required="true">New session</button>
        <button onclick="listSessions()" data-repo-required="true">List sessions</button>
      </div>
      <pre id="sessions"></pre>
    </section>

    <section class="section">
      <h2>Diff</h2>
      <div class="row">
        <input id="sessionId" placeholder="Session ID" style="min-width: 260px" />
        <button onclick="showDiff()" data-repo-required="true">Show diff</button>
        <button onclick="copyToClipboard('diff')">Copy diff</button>
        <button onclick="downloadDiff()" data-repo-required="true">Download diff</button>
      </div>
      <pre id="diff"></pre>
    </section>

    <section class="section">
      <h2>Apply patch (aus ChatGPT)</h2>
      <textarea id="patch" placeholder="Paste patch here..."></textarea>
      <div class="row">
        <label>
          <input type="checkbox" id="threeWay" />
          Apply mit --3way (toleranter, kann Merges erzeugen)
        </label>
      </div>
      <div class="row">
        <input id="applySessionId" placeholder="Jules Session ID (optional)" style="min-width: 260px" />
      </div>
      <div class="row">
        <button onclick="applyPatch()" data-repo-required="true">Apply patch</button>
      </div>
      <div id="applyStatus" class="status"></div>
      <pre id="applyOut"></pre>
    </section>

    <section class="section">
      <h2>PR Wizard (Git)</h2>
      <div class="row">
        <input id="branch" placeholder="branch name (z.B. acs/session-xyz)" style="min-width: 260px" />
        <button onclick="createBranch()" data-repo-required="true">Create branch</button>
        <button onclick="gitStatus()" data-repo-required="true">Status</button>
        <button onclick="gitDiff()" data-repo-required="true">Diff</button>
      </div>
      <div class="row">
        <input id="msg" placeholder="commit message" style="min-width: 360px" />
        <button onclick="gitCommit()" data-repo-required="true">Commit</button>
        <button onclick="gitPush()" data-repo-required="true">Push</button>
        <button onclick="gitPreparePr()" data-repo-required="true">Prepare PR</button>
      </div>
      <div class="row">
        <input id="prTitle" placeholder="PR title (optional)" style="min-width: 360px" />
        <input id="prBase" placeholder="Base branch (default: main)" style="min-width: 220px" />
        <label>
          <input type="checkbox" id="prDraft" checked />
          Draft PR
        </label>
        <label>
          <input type="checkbox" id="includeDiffstat" checked />
          Include diffstat
        </label>
      </div>
      <div class="row">
        <textarea id="prBody" placeholder="PR body (optional)" style="min-height: 120px"></textarea>
      </div>
      <div class="row">
        <button onclick="publish()" data-repo-required="true">Publish (Push + PR)</button>
        <button onclick="downloadPublishLog()" id="publishDownload" disabled>Download publish log</button>
      </div>
      <div id="publishStatus" class="status"></div>
      <div id="publishPrUrl" class="small"></div>
      <pre id="publishOut"></pre>
      <pre id="gitOut"></pre>
    </section>

    <script>
      async function api(path, body) {
        const res = await fetch(path, {
          method: body ? "POST" : "GET",
          headers: body ? { "Content-Type": "application/json" } : undefined,
          body: body ? JSON.stringify(body) : undefined,
        });
        const txt = await res.text();
        if (!res.ok) {
          const message = formatErrorMessage(txt);
          throw new Error(message);
        }
        return txt;
      }
      function repo() {
        return document.getElementById("repo").value.trim();
      }
      function ensureRepo(onError) {
        const value = repo();
        if (!value) {
          const message = "Bitte zuerst ein Repo auswählen.";
          if (onError) onError(message);
          updateRepoDependentState();
          return null;
        }
        return value;
      }
      function truncateText(text, max = 2000) {
        const value = String(text ?? "");
        if (value.length <= max) return value;
        return `${value.slice(0, max)}\n… (truncated)`;
      }
      function safeStringify(value) {
        const seen = new WeakSet();
        try {
          return truncateText(
            JSON.stringify(value, (_key, val) => {
              if (val && typeof val === "object") {
                if (seen.has(val)) return "[Circular]";
                seen.add(val);
              }
              return val;
            }),
          );
        } catch (err) {
          try {
            const ctor =
              value && typeof value === "object" && value.constructor
                ? value.constructor.name
                : undefined;
            const keys = value && typeof value === "object" ? Object.keys(value) : [];
            return truncateText(
              JSON.stringify({
                unstringifiable: true,
                type: typeof value,
                constructor: ctor,
                keys,
              }),
            );
          } catch (fallbackErr) {
            return "Unstringifiable error object";
          }
        }
      }
      function formatFastApiDetail(detail) {
        if (Array.isArray(detail)) {
          const parts = detail
            .map((item) => {
              if (!item) return "";
              const loc = Array.isArray(item.loc) ? item.loc.join(".") : item.loc;
              if (item.msg) {
                if (loc && item.msg === "Field required" && loc.startsWith("query.")) {
                  return `Missing query param: ${loc.split(".").slice(1).join(".")}`;
                }
                if (loc) return `${loc}: ${item.msg}`;
                return item.msg;
              }
              return String(item);
            })
            .filter(Boolean);
          return parts.join("; ");
        }
        if (typeof detail === "string") return detail;
        if (detail && typeof detail === "object") {
          if (detail.detail) {
            const nested = formatFastApiDetail(detail.detail);
            if (nested) return nested;
          }
          if (detail.msg) return String(detail.msg);
          if (detail.error) return String(detail.error);
          if (detail.message) return String(detail.message);
          return safeStringify(detail);
        }
        return "";
      }
      function formatErrorMessage(text) {
        const rawText = text == null ? "" : String(text);
        if (!rawText) return "Request failed";
        try {
          const parsed = JSON.parse(rawText);
          if (parsed?.detail !== undefined) {
            const detailMessage = formatFastApiDetail(parsed.detail);
            if (detailMessage) return String(detailMessage);
          }
          if (parsed?.message) return String(parsed.message);
          if (parsed?.error) return String(parsed.error);
          if (parsed?.msg) return String(parsed.msg);
          if (parsed && typeof parsed === "object") {
            return safeStringify(parsed);
          }
        } catch (err) {
          // ignore JSON parse errors
        }
        return rawText.split("\n")[0] || "Request failed";
      }
      function updateRepoDependentState() {
        const disabled = !repo();
        document.querySelectorAll("[data-repo-required=\"true\"]").forEach((el) => {
          el.disabled = disabled;
        });
      }
      document.addEventListener("DOMContentLoaded", () => {
        updateRepoDependentState();
        document.getElementById("repo").addEventListener("change", updateRepoDependentState);
      });

      async function listSessions() {
        const repoValue = ensureRepo((message) => {
          document.getElementById("sessions").textContent = message;
        });
        if (!repoValue) return;
        document.getElementById("sessions").textContent = await api(
          `/api/sessions?repo=${encodeURIComponent(repoValue)}`,
        );
      }
      async function newSession() {
        const repoValue = ensureRepo((message) => {
          document.getElementById("sessions").textContent = message;
        });
        if (!repoValue) return;
        const title = document.getElementById("title").value || "untitled";
        document.getElementById("sessions").textContent = await api(
          "/api/sessions/new",
          { repo: repoValue, title },
        );
      }
      async function showDiff() {
        const id = document.getElementById("sessionId").value.trim();
        if (!id) return;
        const repoValue = ensureRepo((message) => {
          document.getElementById("diff").textContent = message;
        });
        if (!repoValue) return;
        document.getElementById("diff").textContent = await api(
          `/api/sessions/${encodeURIComponent(id)}/diff?repo=${encodeURIComponent(repoValue)}`,
        );
      }
      function downloadDiff() {
        const id = document.getElementById("sessionId").value.trim();
        if (!id) return;
        const repoValue = ensureRepo((message) => {
          document.getElementById("diff").textContent = message;
        });
        if (!repoValue) return;
        const url = `/api/sessions/${encodeURIComponent(id)}/diff/download?repo=${encodeURIComponent(
          repoValue,
        )}`;
        window.location.href = url;
      }
      async function applyPatch() {
        const patch = document.getElementById("patch").value;
        const threeWay = document.getElementById("threeWay").checked;
        const sessionId = document.getElementById("applySessionId").value.trim();
        const repoValue = ensureRepo((message) => {
          setApplyStatus(`❌ ${message}`, "error");
          document.getElementById("applyOut").textContent = "";
        });
        if (!repoValue) return;
        const body = { repo: repoValue, patch, three_way: threeWay };
        if (sessionId) body.session_id = sessionId;
        try {
          const res = await fetch("/api/patch/apply.json", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body),
          });
          if (!res.ok) {
            const errorText = await res.text();
            let summary = errorText.split("\n")[0];
            try {
              const parsed = JSON.parse(errorText);
              summary = parsed.message || parsed.error_kind || summary;
            } catch (err) {
              // ignore JSON parse errors
            }
            setApplyStatus(`❌ Patch fehlgeschlagen: ${summary}`, "error");
            document.getElementById("applyOut").textContent = errorText;
            return;
          }
          const contentType = res.headers.get("Content-Type") || "";
          if (!contentType.includes("application/json")) {
            const errorText = await res.text();
            const [summary, ...rest] = errorText.split("\n");
            setApplyStatus(`❌ Patch fehlgeschlagen: ${summary}`, "error");
            document.getElementById("applyOut").textContent = rest.join("\n").trim();
            return;
          }
          const data = await res.json();
          const status = formatApplyStatus(data);
          setApplyStatus(status.text, status.state);
          document.getElementById("applyOut").textContent = data.stdout || "";
        } catch (error) {
          setApplyStatus(`❌ Patch fehlgeschlagen: ${error.message}`, "error");
          document.getElementById("applyOut").textContent = "";
          return;
        }
      }
      async function createBranch() {
        const name = document.getElementById("branch").value.trim();
        const repoValue = ensureRepo((message) => {
          document.getElementById("gitOut").textContent = message;
        });
        if (!repoValue) return;
        document.getElementById("gitOut").textContent = await api(
          "/api/git/branch",
          { repo: repoValue, name },
        );
      }
      async function gitStatus() {
        const repoValue = ensureRepo((message) => {
          document.getElementById("gitOut").textContent = message;
        });
        if (!repoValue) return;
        document.getElementById("gitOut").textContent = await api(
          `/api/git/status?repo=${encodeURIComponent(repoValue)}`,
        );
      }
      async function gitDiff() {
        const repoValue = ensureRepo((message) => {
          document.getElementById("gitOut").textContent = message;
        });
        if (!repoValue) return;
        document.getElementById("gitOut").textContent = await api(
          `/api/git/diff?repo=${encodeURIComponent(repoValue)}`,
        );
      }
      async function gitCommit() {
        const message = document.getElementById("msg").value.trim();
        const repoValue = ensureRepo((notice) => {
          document.getElementById("gitOut").textContent = notice;
        });
        if (!repoValue) return;
        document.getElementById("gitOut").textContent = await api(
          "/api/git/commit",
          { repo: repoValue, message },
        );
      }
      async function gitPush() {
        const repoValue = ensureRepo((message) => {
          document.getElementById("gitOut").textContent = message;
        });
        if (!repoValue) return;
        document.getElementById("gitOut").textContent = await api(
          "/api/git/push",
          { repo: repoValue },
        );
      }
      async function gitPreparePr() {
        const repoValue = ensureRepo((message) => {
          document.getElementById("gitOut").textContent = message;
        });
        if (!repoValue) return;
        document.getElementById("gitOut").textContent = await api(
          `/api/git/pr-prepare?repo=${encodeURIComponent(repoValue)}`,
        );
      }
      function copyToClipboard(id) {
        const text = document.getElementById(id).textContent;
        navigator.clipboard.writeText(text);
      }
      function setApplyStatus(text, state) {
        const status = document.getElementById("applyStatus");
        status.textContent = text;
        status.className = `status ${state || ""}`.trim();
      }
      function formatApplyStatus(data) {
        const filesChanged = data?.files?.length;
        if (data.ok && data.changed) {
          const suffix = filesChanged ? ` (${filesChanged} Dateien im Patch)` : "";
          return { text: `✔ Patch angewendet${suffix}.`, state: "success" };
        }
        if (data.ok && !data.changed) {
          return { text: "⚠ Patch angewendet, aber keine Änderungen.", state: "warn" };
        }
        const summary = (data.message || "Unbekannter Fehler").split("\n")[0];
        return { text: `❌ Patch fehlgeschlagen: ${summary}`, state: "error" };
      }

      let publishJobId = null;
      let publishPoll = null;
      let publishData = null;

      async function publish() {
        const repoValue = ensureRepo((message) => {
          setPublishStatus(`❌ ${message}`, "error");
        });
        if (!repoValue) return;
        const payload = {};
        const branchName = document.getElementById("branch").value.trim();
        const commitMessage = document.getElementById("msg").value.trim();
        const prTitle = document.getElementById("prTitle").value.trim();
        const prBody = document.getElementById("prBody").value.trim();
        const prBase = document.getElementById("prBase").value.trim();
        const prDraft = document.getElementById("prDraft").checked;
        const includeDiffstat = document.getElementById("includeDiffstat").checked;
        if (branchName) payload.branch = branchName;
        if (commitMessage) payload.commit_message = commitMessage;
        if (prTitle) payload.pr_title = prTitle;
        if (prBody) payload.pr_body = prBody;
        if (prBase) payload.base = prBase;
        payload.draft = prDraft;
        payload.include_diffstat = includeDiffstat;
        setPublishStatus("Publish gestartet…", "warn");
        document.getElementById("publishPrUrl").textContent = "";
        document.getElementById("publishOut").textContent = "";
        document.getElementById("publishDownload").disabled = true;
        try {
          const res = await fetch(`/api/git/publish?repo=${encodeURIComponent(repoValue)}`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          const errorText = await res.text();
          let data = null;
          if (errorText) {
            try {
              data = JSON.parse(errorText);
            } catch (err) {
              // ignore JSON parse errors
            }
          }
          if (!res.ok) {
            document.getElementById("publishOut").textContent =
              errorText || "No response body returned.";
            const message = data ? formatErrorMessage(errorText) : errorText || "Publish failed";
            throw new Error(String(message));
          }
          if (!data) {
            throw new Error("Publish failed: invalid response");
          }
          publishJobId = data.job_id;
          publishData = null;
          setPublishStatus(`Job queued (${data.job_id})`, "warn");
          startPublishPolling();
        } catch (error) {
          const message =
            error instanceof TypeError
              ? `Network error: ${error.message || "fetch failed"} (Tunnel/Verbindung prüfen)`
              : String(error?.message ?? error);
          setPublishStatus(`❌ Publish fehlgeschlagen: ${message}`, "error");
        }
      }

      function startPublishPolling() {
        if (publishPoll) {
          clearInterval(publishPoll);
        }
        publishPoll = setInterval(async () => {
          if (!publishJobId) return;
          try {
            const res = await fetch(`/api/jobs/${publishJobId}`);
            const errorText = await res.text();
            let data = null;
            if (errorText) {
              try {
                data = JSON.parse(errorText);
              } catch (err) {
                // ignore JSON parse errors
              }
            }
            if (!res.ok) {
              document.getElementById("publishOut").textContent =
                errorText || "No response body returned.";
              const message = data ? formatErrorMessage(errorText) : errorText || "Job failed";
              throw new Error(String(message));
            }
            if (!data) {
              throw new Error("Job failed: invalid response");
            }
            publishData = data;
            renderPublishJob(data);
            if (data.status === "done" || data.status === "error") {
              clearInterval(publishPoll);
              publishPoll = null;
            }
          } catch (error) {
            const message =
              error instanceof TypeError
                ? `Network error: ${error.message || "fetch failed"} (Tunnel/Verbindung prüfen)`
                : String(error?.message ?? error);
            setPublishStatus(`⚠️ Publish polling failed: ${message}`, "warn");
          }
        }, 2000);
      }

      function renderPublishJob(data) {
        const statusMap = {
          queued: { text: "Publish queued", state: "warn" },
          running: { text: "Publish läuft…", state: "warn" },
          done: { text: "Publish abgeschlossen", state: "success" },
          error: { text: "Publish fehlgeschlagen", state: "error" },
        };
        const status = statusMap[data.status] || { text: data.status, state: "warn" };
        setPublishStatus(status.text, status.state);
        const results = data.results || [];
        const branch = results.find((res) => res.branch)?.branch;
        if (branch) {
          document.getElementById("branch").value = branch;
        }
        const prUrl = results.find((res) => res.pr_url)?.pr_url;
        if (prUrl) {
          document.getElementById("publishPrUrl").innerHTML = `<a href="${prUrl}" target="_blank">${prUrl}</a>`;
        }
        document.getElementById("publishOut").textContent = formatPublishResults(results, data.log_tail);
        document.getElementById("publishDownload").disabled = !results.length;
      }

      function formatPublishResults(results, logTail) {
        const parts = results.map((res) => {
          const header = `${res.ok ? "✔" : "❌"} ${res.action}`;
          const summary = res.message || "";
          const error = res.error_kind ? `error_kind=${res.error_kind}` : "";
          const stdout = truncateOutput(res.stdout);
          const stderr = truncateOutput(res.stderr);
          const block = [];
          if (summary) block.push(summary);
          if (error) block.push(error);
          if (stdout) block.push(`stdout:\n${stdout}`);
          if (stderr) block.push(`stderr:\n${stderr}`);
          return [header, ...block].join("\n");
        });
        if (logTail) {
          parts.push(`\nLog tail:\n${logTail}`);
        }
        return parts.join("\n\n");
      }

      function truncateOutput(text) {
        if (!text) return "";
        const max = 2000;
        if (text.length <= max) return text;
        return `${text.slice(0, max)}\n… (truncated)`;
      }

      function downloadPublishLog() {
        if (!publishData) return;
        const blob = new Blob([JSON.stringify(publishData, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `acs-publish-${publishJobId || "log"}.json`;
        a.click();
        URL.revokeObjectURL(url);
      }

      function setPublishStatus(text, state) {
        const status = document.getElementById("publishStatus");
        status.textContent = text;
        status.className = `status ${state || ""}`.trim();
      }
    </script>
  </body>
</html>
