<!doctype html>
<html lang="de">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>agent-control-surface (acs)</title>
    <style>
      :root {
        color-scheme: light dark;
      }
      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        margin: 16px;
        line-height: 1.4;
      }
      h1 {
        margin-bottom: 8px;
      }
      label {
        font-weight: 600;
      }
      .row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-bottom: 8px;
      }
      button {
        padding: 10px 14px;
        font-size: 16px;
      }
      input,
      select,
      textarea {
        padding: 10px;
        font-size: 16px;
      }
      textarea {
        width: 100%;
        min-height: 220px;
      }
      pre {
        white-space: pre-wrap;
        word-break: break-word;
        padding: 12px;
        background: #f3f3f3;
        border-radius: 6px;
        max-height: 360px;
        overflow: auto;
      }
      .section {
        margin-top: 24px;
      }
      .small {
        font-size: 14px;
        opacity: 0.8;
      }
      .status {
        font-weight: 600;
        margin-top: 8px;
      }
      .status.success {
        color: #2e7d32;
      }
      .status.warn {
        color: #b36b00;
      }
      .status.error {
        color: #c62828;
      }
      .callout {
        margin-top: 8px;
        padding: 10px 12px;
        border-radius: 6px;
        background: rgba(255, 193, 7, 0.15);
        border: 1px solid rgba(255, 193, 7, 0.4);
      }
    </style>
  </head>
  <body>
    <h1>agent-control-surface (acs)</h1>
    <p class="small">Local-only Control Surface for Jules & Git.</p>

    <label for="repo">Repo</label>
    <select id="repo">
      <option value="">-- Repo auswählen --</option>
      {% for repo in repos %}
      <option value="{{ repo.key }}">{{ repo.display }}</option>
      {% endfor %}
    </select>

    <section class="section">
      <h2>Sessions</h2>
      <div class="row">
        <input id="title" placeholder="New session title" style="min-width: 260px" />
        <button onclick="newSession()" data-repo-required="true">New session</button>
        <button onclick="listSessions()" data-repo-required="true">List sessions</button>
      </div>
      <pre id="sessions"></pre>
    </section>

    <section class="section">
      <h2>Diff</h2>
      <div class="row">
        <input id="sessionId" placeholder="Session ID" style="min-width: 260px" />
        <button onclick="showDiff()" data-repo-required="true">Show diff</button>
        <button onclick="copyToClipboard('diff')">Copy diff</button>
        <button onclick="downloadDiff()" data-repo-required="true">Download diff</button>
      </div>
      <pre id="diff"></pre>
    </section>

    <section class="section">
      <h2>Apply patch (aus ChatGPT)</h2>
      <textarea id="patch" placeholder="Paste patch here..."></textarea>
      <div class="row">
        <label>
          <input type="checkbox" id="threeWay" />
          Apply mit --3way (toleranter, kann Merges erzeugen)
        </label>
      </div>
      <div class="row">
        <input id="applySessionId" placeholder="Jules Session ID (optional)" style="min-width: 260px" />
      </div>
      <div class="row">
        <button onclick="applyPatch()" data-repo-required="true">Apply patch</button>
      </div>
      <div id="applyStatus" class="status"></div>
      <pre id="applyOut"></pre>
    </section>

    <section class="section">
      <h2>PR Wizard (Git)</h2>
      <div class="row">
        <input id="branch" placeholder="branch name (z.B. acs/session-xyz)" style="min-width: 260px" />
        <button onclick="createBranch()" data-repo-required="true">Create branch</button>
        <button onclick="gitStatus()" data-repo-required="true">Status</button>
        <button onclick="gitDiff()" data-repo-required="true">Diff</button>
      </div>
      <div class="row">
        <input id="msg" placeholder="commit message" style="min-width: 360px" />
        <button onclick="gitCommit()" data-repo-required="true">Commit</button>
        <button onclick="gitPush()" data-repo-required="true">Push</button>
        <button onclick="gitPreparePr()" data-repo-required="true">Prepare PR</button>
      </div>
      <div class="row">
        <input id="prTitle" placeholder="PR title (optional)" style="min-width: 360px" />
        <input id="prBase" placeholder="Base branch (default: main)" style="min-width: 220px" />
        <label>
          <input type="checkbox" id="prDraft" checked />
          Draft PR
        </label>
        <label>
          <input type="checkbox" id="includeDiffstat" checked />
          Include diffstat
        </label>
      </div>
      <div class="row">
        <textarea id="prBody" placeholder="PR body (optional)" style="min-height: 120px"></textarea>
      </div>
      <div class="row">
        <button onclick="publish()" data-repo-required="true">Publish (Push + PR)</button>
        <button onclick="downloadPublishLog()" id="publishDownload" disabled>Download publish log</button>
      </div>
      <div class="row">
        <button onclick="gitDiagnose()" data-repo-required="true">Diagnose Git (read-only)</button>
        <button onclick="gitRepairStageA()" data-repo-required="true">Repair Git Refs (Stage A)</button>
        <button onclick="gitRepairStageB()" data-repo-required="true">Repair Git Refs (Stage B)</button>
        <button onclick="gitRepairStageC()" data-repo-required="true">
          Repair Git Refs (Stage C – pack-refs, nur wenn A/B nicht helfen)
        </button>
      </div>
      <div class="row small">
        <label>
          <input type="checkbox" id="repairDeleteBase" />
          Stage B: also delete origin/&lt;base&gt; (nur bei klarer Diagnose)
        </label>
      </div>
      <div class="small">
        Nur lokale Tracking-Refs (refs/remotes/origin/*). Keine lokalen Branches und keine Remote-Branches
        werden geändert.
      </div>
      <div id="gitRepairOffer" class="callout small" style="display: none"></div>
      <div id="publishStatus" class="status"></div>
      <div id="publishPrUrl" class="small"></div>
      <pre id="publishOut"></pre>
      <pre id="gitOut"></pre>
    </section>

    <section class="section" id="ops-panel">
      <h2>Ops / Git Health (Audit)</h2>
      <div class="row">
        <button onclick="auditGit()" data-repo-required="true">Audit Git</button>
      </div>
      <div id="auditStatus" class="status"></div>

      <!-- JSON Viewer / Result Display -->
      <div id="auditResultContainer" style="display: none; margin-top: 12px;">
        <div class="row small">
          <strong>Status:</strong> <span id="auditMetaStatus"></span>
          &nbsp;|&nbsp;
          <strong>Branch:</strong> <span id="auditMetaBranch"></span>
          &nbsp;|&nbsp;
          <strong>Upstream:</strong> <span id="auditMetaUpstream"></span>
        </div>

        <div class="row" style="margin-top: 8px;">
          <button onclick="toggleAuditJson()" class="small">JSON anzeigen/verbergen</button>
          <button onclick="copyToClipboard('auditJson')" class="small">JSON kopieren</button>
        </div>
        <pre id="auditJson" style="display: none;"></pre>

        <div id="auditRoutines" class="callout" style="display: none; margin-top: 12px;">
          <strong>Vorgeschlagene Routinen:</strong>
          <div id="auditRoutinesList" style="display: flex; flex-direction: column; gap: 8px; margin-top: 8px;"></div>
        </div>
      </div>

      <!-- Routine Preview Modal / Overlay -->
      <div id="routinePreviewContainer" style="display: none; border: 1px solid #ccc; padding: 16px; background: #fff; margin-top: 16px; border-radius: 6px;">
        <h3>Routine Preview: <span id="previewRoutineId"></span></h3>
        <pre id="previewJson" style="max-height: 300px; overflow: auto;"></pre>
        <div class="row">
          <button onclick="confirmApplyRoutine()" class="status error">Confirm & Apply</button>
          <button onclick="cancelPreview()">Cancel</button>
        </div>
        <div id="routineApplyStatus" class="status"></div>
      </div>
    </section>

    <script>
      async function api(path, body) {
        const res = await fetch(path, {
          method: body ? "POST" : "GET",
          headers: body ? { "Content-Type": "application/json" } : undefined,
          body: body ? JSON.stringify(body) : undefined,
        });
        const txt = await res.text();
        if (!res.ok) {
          const message = formatErrorMessage(txt);
          throw new Error(message);
        }
        return txt;
      }
      function repo() {
        return document.getElementById("repo").value.trim();
      }
      function ensureRepo(onError) {
        const value = repo();
        if (!value) {
          const message = "Bitte zuerst ein Repo auswählen.";
          if (onError) onError(message);
          updateRepoDependentState();
          return null;
        }
        return value;
      }
      function truncateText(text, max = 2000) {
        const value = String(text ?? "");
        if (value.length <= max) return value;
        return `${value.slice(0, max)}\n… (truncated)`;
      }
      function safeStringify(value) {
        const seen = new WeakSet();
        try {
          return truncateText(
            JSON.stringify(value, (_key, val) => {
              if (val && typeof val === "object") {
                if (seen.has(val)) return "[Circular]";
                seen.add(val);
              }
              return val;
            }),
          );
        } catch (err) {
          try {
            const ctor =
              value && typeof value === "object" && value.constructor
                ? value.constructor.name
                : undefined;
            const keys = value && typeof value === "object" ? Object.keys(value) : [];
            return truncateText(
              JSON.stringify({
                unstringifiable: true,
                type: typeof value,
                constructor: ctor,
                keys,
              }),
            );
          } catch (fallbackErr) {
            return "Unstringifiable error object";
          }
        }
      }
      function formatFastApiDetail(detail) {
        if (Array.isArray(detail)) {
          const parts = detail
            .map((item) => {
              if (!item) return "";
              const loc = Array.isArray(item.loc) ? item.loc.join(".") : item.loc;
              if (item.msg) {
                if (loc && item.msg === "Field required" && loc.startsWith("query.")) {
                  return `Missing query param: ${loc.split(".").slice(1).join(".")}`;
                }
                if (loc) return `${loc}: ${item.msg}`;
                return item.msg;
              }
              return String(item);
            })
            .filter(Boolean);
          return parts.join("; ");
        }
        if (typeof detail === "string") return detail;
        if (detail && typeof detail === "object") {
          if (detail.detail) {
            const nested = formatFastApiDetail(detail.detail);
            if (nested) return nested;
          }
          if (detail.msg) return String(detail.msg);
          if (detail.error) return String(detail.error);
          if (detail.message) return String(detail.message);
          return safeStringify(detail);
        }
        return "";
      }
      function formatErrorMessage(text) {
        const rawText = text == null ? "" : String(text);
        if (!rawText) return "Request failed";
        try {
          const parsed = JSON.parse(rawText);
          if (parsed?.detail !== undefined) {
            const detailMessage = formatFastApiDetail(parsed.detail);
            if (detailMessage) return String(detailMessage);
          }
          if (parsed?.message) return String(parsed.message);
          if (parsed?.error) return String(parsed.error);
          if (parsed?.msg) return String(parsed.msg);
          if (parsed && typeof parsed === "object") {
            return safeStringify(parsed);
          }
        } catch (err) {
          // ignore JSON parse errors
        }
        return rawText.split("\n")[0] || "Request failed";
      }
      function updateRepoDependentState() {
        const disabled = !repo();
        document.querySelectorAll("[data-repo-required=\"true\"]").forEach((el) => {
          el.disabled = disabled;
        });
      }
      document.addEventListener("DOMContentLoaded", () => {
        updateRepoDependentState();
        document.getElementById("repo").addEventListener("change", updateRepoDependentState);
      });

      async function listSessions() {
        const repoValue = ensureRepo((message) => {
          document.getElementById("sessions").textContent = message;
        });
        if (!repoValue) return;
        document.getElementById("sessions").textContent = await api(
          `/api/sessions?repo=${encodeURIComponent(repoValue)}`,
        );
      }
      async function newSession() {
        const repoValue = ensureRepo((message) => {
          document.getElementById("sessions").textContent = message;
        });
        if (!repoValue) return;
        const title = document.getElementById("title").value || "untitled";
        document.getElementById("sessions").textContent = await api(
          "/api/sessions/new",
          { repo: repoValue, title },
        );
      }
      async function showDiff() {
        const id = document.getElementById("sessionId").value.trim();
        if (!id) return;
        const repoValue = ensureRepo((message) => {
          document.getElementById("diff").textContent = message;
        });
        if (!repoValue) return;
        document.getElementById("diff").textContent = await api(
          `/api/sessions/${encodeURIComponent(id)}/diff?repo=${encodeURIComponent(repoValue)}`,
        );
      }
      function downloadDiff() {
        const id = document.getElementById("sessionId").value.trim();
        if (!id) return;
        const repoValue = ensureRepo((message) => {
          document.getElementById("diff").textContent = message;
        });
        if (!repoValue) return;
        const url = `/api/sessions/${encodeURIComponent(id)}/diff/download?repo=${encodeURIComponent(
          repoValue,
        )}`;
        window.location.href = url;
      }
      async function applyPatch() {
        const patch = document.getElementById("patch").value;
        const threeWay = document.getElementById("threeWay").checked;
        const sessionId = document.getElementById("applySessionId").value.trim();
        const repoValue = ensureRepo((message) => {
          setApplyStatus(`❌ ${message}`, "error");
          document.getElementById("applyOut").textContent = "";
        });
        if (!repoValue) return;
        const body = { repo: repoValue, patch, three_way: threeWay };
        if (sessionId) body.session_id = sessionId;
        try {
          const res = await fetch("/api/patch/apply.json", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body),
          });
          if (!res.ok) {
            const errorText = await res.text();
            let summary = errorText.split("\n")[0];
            try {
              const parsed = JSON.parse(errorText);
              summary = parsed.message || parsed.error_kind || summary;
            } catch (err) {
              // ignore JSON parse errors
            }
            setApplyStatus(`❌ Patch fehlgeschlagen: ${summary}`, "error");
            document.getElementById("applyOut").textContent = errorText;
            return;
          }
          const contentType = res.headers.get("Content-Type") || "";
          if (!contentType.includes("application/json")) {
            const errorText = await res.text();
            const [summary, ...rest] = errorText.split("\n");
            setApplyStatus(`❌ Patch fehlgeschlagen: ${summary}`, "error");
            document.getElementById("applyOut").textContent = rest.join("\n").trim();
            return;
          }
          const data = await res.json();
          const status = formatApplyStatus(data);
          setApplyStatus(status.text, status.state);
          document.getElementById("applyOut").textContent = data.stdout || "";
        } catch (error) {
          setApplyStatus(`❌ Patch fehlgeschlagen: ${error.message}`, "error");
          document.getElementById("applyOut").textContent = "";
          return;
        }
      }
      async function createBranch() {
        const name = document.getElementById("branch").value.trim();
        const repoValue = ensureRepo((message) => {
          document.getElementById("gitOut").textContent = message;
        });
        if (!repoValue) return;
        document.getElementById("gitOut").textContent = await api(
          "/api/git/branch",
          { repo: repoValue, name },
        );
      }
      async function gitStatus() {
        const repoValue = ensureRepo((message) => {
          document.getElementById("gitOut").textContent = message;
        });
        if (!repoValue) return;
        document.getElementById("gitOut").textContent = await api(
          `/api/git/status?repo=${encodeURIComponent(repoValue)}`,
        );
      }
      async function gitDiff() {
        const repoValue = ensureRepo((message) => {
          document.getElementById("gitOut").textContent = message;
        });
        if (!repoValue) return;
        document.getElementById("gitOut").textContent = await api(
          `/api/git/diff?repo=${encodeURIComponent(repoValue)}`,
        );
      }
      async function gitCommit() {
        const message = document.getElementById("msg").value.trim();
        const repoValue = ensureRepo((notice) => {
          document.getElementById("gitOut").textContent = notice;
        });
        if (!repoValue) return;
        document.getElementById("gitOut").textContent = await api(
          "/api/git/commit",
          { repo: repoValue, message },
        );
      }
      async function gitPush() {
        const repoValue = ensureRepo((message) => {
          document.getElementById("gitOut").textContent = message;
        });
        if (!repoValue) return;
        document.getElementById("gitOut").textContent = await api(
          "/api/git/push",
          { repo: repoValue },
        );
      }
      async function gitPreparePr() {
        const repoValue = ensureRepo((message) => {
          document.getElementById("gitOut").textContent = message;
        });
        if (!repoValue) return;
        document.getElementById("gitOut").textContent = await api(
          `/api/git/pr-prepare?repo=${encodeURIComponent(repoValue)}`,
        );
      }
      function copyToClipboard(id) {
        const text = document.getElementById(id).textContent;
        navigator.clipboard.writeText(text);
      }
      function setApplyStatus(text, state) {
        const status = document.getElementById("applyStatus");
        status.textContent = text;
        status.className = `status ${state || ""}`.trim();
      }
      function formatApplyStatus(data) {
        const filesChanged = data?.files?.length;
        if (data.ok && data.changed) {
          const suffix = filesChanged ? ` (${filesChanged} Dateien im Patch)` : "";
          return { text: `✔ Patch angewendet${suffix}.`, state: "success" };
        }
        if (data.ok && !data.changed) {
          return { text: "⚠ Patch angewendet, aber keine Änderungen.", state: "warn" };
        }
        const summary = (data.message || "Unbekannter Fehler").split("\n")[0];
        return { text: `❌ Patch fehlgeschlagen: ${summary}`, state: "error" };
      }

      let publishJobId = null;
      let publishPoll = null;
      let publishData = null;
      let publishJobMode = "publish";

      async function publish() {
        const repoValue = ensureRepo((message) => {
          setPublishStatus(`❌ ${message}`, "error");
        });
        if (!repoValue) return;
        publishJobMode = "publish";
        const payload = {};
        const branchName = document.getElementById("branch").value.trim();
        const commitMessage = document.getElementById("msg").value.trim();
        const prTitle = document.getElementById("prTitle").value.trim();
        const prBody = document.getElementById("prBody").value.trim();
        const prBase = document.getElementById("prBase").value.trim();
        const prDraft = document.getElementById("prDraft").checked;
        const includeDiffstat = document.getElementById("includeDiffstat").checked;
        if (branchName) payload.branch = branchName;
        if (commitMessage) payload.commit_message = commitMessage;
        if (prTitle) payload.pr_title = prTitle;
        if (prBody) payload.pr_body = prBody;
        if (prBase) payload.base = prBase;
        payload.draft = prDraft;
        payload.include_diffstat = includeDiffstat;
        setPublishStatus("Publish gestartet…", "warn");
        clearGitRepairOffer();
        document.getElementById("publishPrUrl").textContent = "";
        document.getElementById("publishOut").textContent = "";
        document.getElementById("publishDownload").disabled = true;
        try {
          const res = await fetch(`/api/git/publish?repo=${encodeURIComponent(repoValue)}`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          const errorText = await res.text();
          let data = null;
          if (errorText) {
            try {
              data = JSON.parse(errorText);
            } catch (err) {
              // ignore JSON parse errors
            }
          }
          if (!res.ok) {
            document.getElementById("publishOut").textContent =
              errorText || "No response body returned.";
            const message = data ? formatErrorMessage(errorText) : errorText || "Publish failed";
            throw new Error(String(message));
          }
          if (!data) {
            throw new Error("Publish failed: invalid response");
          }
          publishJobId = data.job_id;
          publishData = null;
          setPublishStatus(`Job queued (${data.job_id})`, "warn");
          startPublishPolling();
        } catch (error) {
          const message =
            error instanceof TypeError
              ? `Network error: ${error.message || "fetch failed"} (Tunnel/Verbindung prüfen)`
              : String(error?.message ?? error);
          setPublishStatus(`❌ Publish fehlgeschlagen: ${message}`, "error");
        }
      }

      async function startGitHealthJob(path, body) {
        const repoValue = ensureRepo((message) => {
          setPublishStatus(`❌ ${message}`, "error");
        });
        if (!repoValue) return;
        publishJobMode = "git-health";
        setPublishStatus("Git-Health-Job gestartet…", "warn");
        clearGitRepairOffer();
        document.getElementById("publishPrUrl").textContent = "";
        document.getElementById("publishOut").textContent = "";
        document.getElementById("publishDownload").disabled = true;
        const options = { method: "POST" };
        if (body) {
          options.headers = { "Content-Type": "application/json" };
          options.body = JSON.stringify(body);
        }
        try {
          const res = await fetch(`${path}?repo=${encodeURIComponent(repoValue)}`, options);
          const errorText = await res.text();
          let data = null;
          if (errorText) {
            try {
              data = JSON.parse(errorText);
            } catch (err) {
              // ignore JSON parse errors
            }
          }
          if (!res.ok) {
            document.getElementById("publishOut").textContent =
              errorText || "No response body returned.";
            const message = data ? formatErrorMessage(errorText) : errorText || "Job failed";
            throw new Error(String(message));
          }
          if (!data) {
            throw new Error("Job failed: invalid response");
          }
          publishJobId = data.job_id;
          publishData = null;
          setPublishStatus(`Job queued (${data.job_id})`, "warn");
          startPublishPolling();
        } catch (error) {
          const message =
            error instanceof TypeError
              ? `Network error: ${error.message || "fetch failed"} (Tunnel/Verbindung prüfen)`
              : String(error?.message ?? error);
          setPublishStatus(`❌ Git-Health-Job fehlgeschlagen: ${message}`, "error");
        }
      }

      function gitDiagnose() {
        startGitHealthJob("/api/git/health/diagnose");
      }
      function gitRepairStageA() {
        startGitHealthJob("/api/git/health/repair/stage-a");
      }
      function gitRepairStageB() {
        const deleteBaseRef = document.getElementById("repairDeleteBase").checked;
        const base = document.getElementById("prBase").value.trim();
        startGitHealthJob("/api/git/health/repair/stage-b", {
          base_branch: base || "main",
          delete_base_ref: deleteBaseRef,
        });
      }
      function gitRepairStageC() {
        startGitHealthJob("/api/git/health/repair/stage-c");
      }

      function startPublishPolling() {
        if (publishPoll) {
          clearInterval(publishPoll);
        }
        publishPoll = setInterval(async () => {
          if (!publishJobId) return;
          try {
            const res = await fetch(`/api/jobs/${publishJobId}`);
            const errorText = await res.text();
            let data = null;
            if (errorText) {
              try {
                data = JSON.parse(errorText);
              } catch (err) {
                // ignore JSON parse errors
              }
            }
            if (!res.ok) {
              document.getElementById("publishOut").textContent =
                errorText || "No response body returned.";
              const message = data ? formatErrorMessage(errorText) : errorText || "Job failed";
              throw new Error(String(message));
            }
            if (!data) {
              throw new Error("Job failed: invalid response");
            }
            publishData = data;
            renderPublishJob(data);
            if (data.status === "done" || data.status === "error") {
              clearInterval(publishPoll);
              publishPoll = null;
            }
          } catch (error) {
            const message =
              error instanceof TypeError
                ? `Network error: ${error.message || "fetch failed"} (Tunnel/Verbindung prüfen)`
                : String(error?.message ?? error);
            setPublishStatus(`⚠️ Publish polling failed: ${message}`, "warn");
          }
        }, 2000);
      }

      function renderPublishJob(data) {
        const statusMap =
          publishJobMode === "git-health"
            ? {
                queued: { text: "Git-Health queued", state: "warn" },
                running: { text: "Git-Health läuft…", state: "warn" },
                done: { text: "Git-Health abgeschlossen", state: "success" },
                error: { text: "Git-Health fehlgeschlagen", state: "error" },
              }
            : {
                queued: { text: "Publish queued", state: "warn" },
                running: { text: "Publish läuft…", state: "warn" },
                done: { text: "Publish abgeschlossen", state: "success" },
                error: { text: "Publish fehlgeschlagen", state: "error" },
              };
        const results = data.results || [];
        let status = statusMap[data.status] || { text: data.status, state: "warn" };
        if (data.status === "error" && results.length) {
          const hasFatal = results.some(
            (result) => !result.ok && result.action !== "git.branch.upstream"
          );
          if (!hasFatal) {
            status = { text: "Publish abgeschlossen (ohne upstream).", state: "warn" };
          } else {
            for (let idx = results.length - 1; idx >= 0; idx -= 1) {
              const result = results[idx];
              if (!result.ok && result.action !== "git.branch.upstream") {
                let detail =
                  result.message || result.error_kind || "Publish failed";
                const maxLen = 200;
                if (detail.length > maxLen) {
                  detail = `${detail.slice(0, maxLen)}…`;
                }
                status = {
                  text: `❌ ${result.action}: ${detail}`,
                  state: "error",
                };
                break;
              }
            }
          }
        }
        setPublishStatus(status.text, status.state);
        if (publishJobMode === "publish") {
          updateGitRepairOffer(results);
        } else {
          clearGitRepairOffer();
        }
        const branch = results.find((res) => res.branch)?.branch;
        if (branch) {
          document.getElementById("branch").value = branch;
        }
        const prUrl = results.find((res) => res.pr_url)?.pr_url;
        const prUrlContainer = document.getElementById("publishPrUrl");
        prUrlContainer.replaceChildren();
        if (prUrl) {
          const link = document.createElement("a");
          link.href = prUrl;
          link.target = "_blank";
          link.rel = "noopener noreferrer";
          link.textContent = prUrl;
          prUrlContainer.append(link);
        }
        document.getElementById("publishOut").textContent = formatPublishResults(results, data.log_tail);
        document.getElementById("publishDownload").disabled = !results.length;
      }

      function formatPublishResults(results, logTail) {
        const parts = results.map((res) => {
          const header = `${res.ok ? "✔" : "❌"} ${res.action}`;
          const summary = res.message || "";
          const error = res.error_kind ? `error_kind=${res.error_kind}` : "";
          const stdout = truncateOutput(res.stdout);
          const stderr = truncateOutput(res.stderr);
          const block = [];
          if (summary) block.push(summary);
          if (error) block.push(error);
          if (stdout) block.push(`stdout:\n${stdout}`);
          if (stderr) block.push(`stderr:\n${stderr}`);
          return [header, ...block].join("\n");
        });
        if (logTail) {
          parts.push(`\nLog tail:\n${logTail}`);
        }
        return parts.join("\n\n");
      }

      function truncateOutput(text) {
        if (!text) return "";
        const max = 2000;
        if (text.length <= max) return text;
        return `${text.slice(0, max)}\n… (truncated)`;
      }

      function downloadPublishLog() {
        if (!publishData) return;
        const blob = new Blob([JSON.stringify(publishData, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `acs-publish-${publishJobId || "log"}.json`;
        a.click();
        URL.revokeObjectURL(url);
      }

      function setPublishStatus(text, state) {
        const status = document.getElementById("publishStatus");
        status.textContent = text;
        status.className = `status ${state || ""}`.trim();
      }

      function clearGitRepairOffer() {
        const offer = document.getElementById("gitRepairOffer");
        offer.style.display = "none";
        offer.replaceChildren();
      }

      function getGitRepairSuggestion(results) {
        const kinds = new Set([
          "ref_lock",
          "dangling_ref",
          "resolve_ref_failed",
          "ref_repair_failed",
        ]);
        for (let idx = results.length - 1; idx >= 0; idx -= 1) {
          const result = results[idx];
          if (result.action === "git.fetch" && !result.ok) {
            if (result.error_kind && kinds.has(result.error_kind)) {
              return {
                message:
                  result.message ||
                  "Local remote refs appear inconsistent. Reparatur kann helfen.",
              };
            }
          }
        }
        return null;
      }

      function updateGitRepairOffer(results) {
        const suggestion = getGitRepairSuggestion(results);
        const offer = document.getElementById("gitRepairOffer");
        if (!suggestion) {
          clearGitRepairOffer();
          return;
        }
        offer.style.display = "block";
        offer.replaceChildren();
        const header = document.createElement("div");
        const strong = document.createElement("strong");
        strong.textContent = "Fix anbieten:";
        const message = document.createElement("span");
        message.textContent = ` ${suggestion.message}`;
        header.append(strong, message);
        const row = document.createElement("div");
        row.className = "row";
        row.style.marginTop = "6px";
        const button = document.createElement("button");
        button.textContent = "Repair Stage A (prune + fetch)";
        button.onclick = gitRepairStageA;
        row.append(button);
        const note = document.createElement("div");
        note.className = "small";
        note.textContent = "Nur lokale Tracking-Refs; keine Remote-Branches.";
        offer.append(header, row, note);
      }

      let auditJobId = null;
      let auditPoll = null;

      async function auditGit() {
        const repoValue = ensureRepo((message) => {
          setAuditStatus(`❌ ${message}`, "error");
        });
        if (!repoValue) return;

        setAuditStatus("Audit gestartet…", "warn");
        document.getElementById("auditResultContainer").style.display = "none";
        document.getElementById("auditRoutines").style.display = "none";
        document.getElementById("auditJson").textContent = "";

        try {
          const res = await fetch(`/api/audit/git?repo=${encodeURIComponent(repoValue)}`, {
            method: "POST",
          });
          if (!res.ok) {
            const txt = await res.text();
            throw new Error(formatErrorMessage(txt));
          }
          const data = await res.json();
          auditJobId = data.job_id;
          setAuditStatus(`Audit läuft (${data.job_id})…`, "warn");
          startAuditPolling();
        } catch (error) {
          setAuditStatus(`❌ Audit fehlgeschlagen: ${error.message}`, "error");
        }
      }

      function startAuditPolling() {
        if (auditPoll) clearInterval(auditPoll);
        auditPoll = setInterval(async () => {
          if (!auditJobId) return;
          try {
            const res = await fetch(`/api/jobs/${auditJobId}`);
            if (!res.ok) throw new Error("Job status fetch failed");
            const data = await res.json();

            if (data.status === "done") {
              clearInterval(auditPoll);

              // Robust extraction: supports array of results or direct result property
              let result = null;
              if (Array.isArray(data.results)) {
                  result = data.results.find((r) => r.action === "audit.git");
              } else if (data.result && data.result.action === "audit.git") {
                  result = data.result;
              }

              if (result && result.audit) {
                renderAudit(result.audit);
                const auditStatus = result.audit.status || "unknown";
                if (auditStatus === "ok") {
                    setAuditStatus("Audit abgeschlossen: OK", "success");
                } else if (auditStatus === "warn") {
                    setAuditStatus("Audit abgeschlossen: Warnungen", "warn");
                } else {
                    setAuditStatus("Audit abgeschlossen: Fehler gefunden", "error");
                }
              } else if (result) {
                setAuditStatus(
                  `❌ Audit beendet, aber kein Ergebnis: ${result.message}`,
                  "error"
                );
              } else {
                setAuditStatus("❌ Audit beendet ohne Ergebnis.", "error");
              }
            } else if (data.status === "error") {
              clearInterval(auditPoll);
              setAuditStatus("❌ Audit fehlgeschlagen (Job Error).", "error");
            }
          } catch (e) {
            setAuditStatus(`⚠️ Polling error: ${e.message}`, "warn");
          }
        }, 1000);
      }

      function renderAudit(audit) {
        document.getElementById("auditResultContainer").style.display = "block";
        document.getElementById("auditJson").textContent = JSON.stringify(audit, null, 2);

        const statusSpan = document.getElementById("auditMetaStatus");
        statusSpan.textContent = audit.status.toUpperCase();
        statusSpan.className =
          audit.status === "ok"
            ? "status success"
            : audit.status === "warn"
            ? "status warn"
            : "status error";

        document.getElementById("auditMetaBranch").textContent =
          audit.facts.local_branch || "(detached)";

        const ups = audit.facts.upstream;
        document.getElementById("auditMetaUpstream").textContent = ups ? ups.name : "(none)";

        const routines = audit.suggested_routines || [];
        const routinesContainer = document.getElementById("auditRoutines");
        const routinesList = document.getElementById("auditRoutinesList");
        routinesList.replaceChildren();

        if (routines.length > 0) {
          routinesContainer.style.display = "block";
          routines.forEach((r) => {
            const card = document.createElement("div");
            card.style.border = "1px solid #ddd";
            card.style.padding = "8px";
            card.style.borderRadius = "4px";
            card.style.background = "#fff";

            const header = document.createElement("div");
            header.style.fontWeight = "bold";
            header.textContent = r.id;

            const meta = document.createElement("div");
            meta.className = "small";
            meta.style.marginBottom = "4px";
            meta.textContent = `Risk: ${r.risk} | Mutating: ${r.mutating}`;

            const reason = document.createElement("div");
            reason.textContent = r.reason;

            const btnRow = document.createElement("div");
            btnRow.style.marginTop = "8px";
            const btn = document.createElement("button");
            btn.textContent = "Preview";
            btn.onclick = () => previewRoutine(r.id);
            btnRow.appendChild(btn);

            card.append(header, meta, reason, btnRow);
            routinesList.appendChild(card);
          });
        } else {
          routinesContainer.style.display = "none";
        }
      }

      let currentRoutineId = null;
      let currentConfirmToken = null;
      let currentPreviewHash = null;

      async function previewRoutine(routineId) {
        const repoValue = ensureRepo();
        if (!repoValue) return;

        currentRoutineId = routineId;
        currentConfirmToken = null;
        currentPreviewHash = null;
        document.getElementById("routinePreviewContainer").style.display = "block";
        document.getElementById("previewRoutineId").textContent = routineId;
        document.getElementById("previewJson").textContent = "Loading preview...";
        document.getElementById("routineApplyStatus").textContent = "";

        try {
          const res = await fetch("/api/routine/preview", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ repo: repoValue, id: routineId }),
          });
          if (!res.ok) {
            if (res.status === 403) {
                throw new Error("Routinen deaktiviert (ACS_ENABLE_ROUTINES=false oder fehlende Rechte).");
            }
            const txt = await res.text();
            throw new Error(formatErrorMessage(txt));
          }
          const data = await res.json();
          document.getElementById("previewJson").textContent = JSON.stringify(data.preview, null, 2);
          currentConfirmToken = data.confirm_token;
          currentPreviewHash = data.preview_hash;
        } catch (e) {
          document.getElementById("previewJson").textContent = `Error: ${e.message}`;
        }
      }

      async function confirmApplyRoutine() {
        if (!currentConfirmToken || !currentRoutineId) return;
        const repoValue = ensureRepo();

        document.getElementById("routineApplyStatus").textContent = "Applying...";

        try {
          const res = await fetch("/api/routine/apply", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              repo: repoValue,
              id: currentRoutineId,
              confirm_token: currentConfirmToken,
              preview_hash: currentPreviewHash
            }),
          });

          if (!res.ok) {
            if (res.status === 403) {
                throw new Error("Routinen deaktiviert (ACS_ENABLE_ROUTINES=false oder fehlende Rechte).");
            }
            const txt = await res.text();
            throw new Error(formatErrorMessage(txt));
          }

          const result = await res.json();
          document.getElementById("routineApplyStatus").textContent = "Success! Re-auditing...";

          // Show result briefly or just reload audit
          setTimeout(() => {
             cancelPreview();
             auditGit(); // Re-audit
          }, 1500);

        } catch (e) {
          document.getElementById("routineApplyStatus").textContent = `Error: ${e.message}`;
          document.getElementById("routineApplyStatus").className = "status error";
        }
      }

      function cancelPreview() {
        document.getElementById("routinePreviewContainer").style.display = "none";
        currentRoutineId = null;
        currentConfirmToken = null;
        currentPreviewHash = null;
      }

      function setAuditStatus(text, state) {
        const el = document.getElementById("auditStatus");
        el.textContent = text;
        el.className = `status ${state || ""}`.trim();
      }

      function toggleAuditJson() {
        const el = document.getElementById("auditJson");
        el.style.display = el.style.display === "none" ? "block" : "none";
      }
    </script>
  </body>
</html>
