<!doctype html>
<html lang="de">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>agent-control-surface (acs)</title>
    <style>
      :root {
        color-scheme: light dark;
      }
      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        margin: 16px;
        line-height: 1.4;
      }
      h1 {
        margin-bottom: 8px;
      }
      label {
        font-weight: 600;
      }
      .row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-bottom: 8px;
      }
      button {
        padding: 10px 14px;
        font-size: 16px;
      }
      input,
      select,
      textarea {
        padding: 10px;
        font-size: 16px;
      }
      textarea {
        width: 100%;
        min-height: 220px;
      }
      pre {
        white-space: pre-wrap;
        word-break: break-word;
        padding: 12px;
        background: #f3f3f3;
        border-radius: 6px;
        max-height: 360px;
        overflow: auto;
      }
      .section {
        margin-top: 24px;
      }
      .small {
        font-size: 14px;
        opacity: 0.8;
      }
      .status {
        font-weight: 600;
        margin-top: 8px;
      }
      .status.success {
        color: #2e7d32;
      }
      .status.warn {
        color: #b36b00;
      }
      .status.error {
        color: #c62828;
      }
    </style>
  </head>
  <body>
    <h1>agent-control-surface (acs)</h1>
    <p class="small">Local-only Control Surface for Jules & Git.</p>

    <label for="repo">Repo</label>
    <select id="repo">
      {% for repo in repos %}
      <option value="{{ repo.key }}">{{ repo.display }}</option>
      {% endfor %}
    </select>

    <section class="section">
      <h2>Sessions</h2>
      <div class="row">
        <input id="title" placeholder="New session title" style="min-width: 260px" />
        <button onclick="newSession()">New session</button>
        <button onclick="listSessions()">List sessions</button>
      </div>
      <pre id="sessions"></pre>
    </section>

    <section class="section">
      <h2>Diff</h2>
      <div class="row">
        <input id="sessionId" placeholder="Session ID" style="min-width: 260px" />
        <button onclick="showDiff()">Show diff</button>
        <button onclick="copyToClipboard('diff')">Copy diff</button>
        <button onclick="downloadDiff()">Download diff</button>
      </div>
      <pre id="diff"></pre>
    </section>

    <section class="section">
      <h2>Apply patch (aus ChatGPT)</h2>
      <textarea id="patch" placeholder="Paste patch here..."></textarea>
      <div class="row">
        <label>
          <input type="checkbox" id="threeWay" />
          Apply mit --3way (toleranter, kann Merges erzeugen)
        </label>
      </div>
      <div class="row">
        <input id="applySessionId" placeholder="Jules Session ID (optional)" style="min-width: 260px" />
      </div>
      <div class="row">
        <button onclick="applyPatch()">Apply patch</button>
      </div>
      <div id="applyStatus" class="status"></div>
      <pre id="applyOut"></pre>
    </section>

    <section class="section">
      <h2>PR Wizard (Git)</h2>
      <div class="row">
        <input id="branch" placeholder="branch name (z.B. acs/session-xyz)" style="min-width: 260px" />
        <button onclick="createBranch()">Create branch</button>
        <button onclick="gitStatus()">Status</button>
        <button onclick="gitDiff()">Diff</button>
      </div>
      <div class="row">
        <input id="msg" placeholder="commit message" style="min-width: 360px" />
        <button onclick="gitCommit()">Commit</button>
        <button onclick="gitPush()">Push</button>
        <button onclick="gitPreparePr()">Prepare PR</button>
      </div>
      <div class="row">
        <input id="prTitle" placeholder="PR title (optional)" style="min-width: 360px" />
        <input id="prBase" placeholder="Base branch (default: main)" style="min-width: 220px" />
        <label>
          <input type="checkbox" id="prDraft" checked />
          Draft PR
        </label>
        <label>
          <input type="checkbox" id="includeDiffstat" checked />
          Include diffstat
        </label>
      </div>
      <div class="row">
        <textarea id="prBody" placeholder="PR body (optional)" style="min-height: 120px"></textarea>
      </div>
      <div class="row">
        <button onclick="publish()">Publish (Push + PR)</button>
        <button onclick="downloadPublishLog()" id="publishDownload" disabled>Download publish log</button>
      </div>
      <div id="publishStatus" class="status"></div>
      <div id="publishPrUrl" class="small"></div>
      <pre id="publishOut"></pre>
      <pre id="gitOut"></pre>
    </section>

    <script>
      async function api(path, body) {
        const res = await fetch(path, {
          method: body ? "POST" : "GET",
          headers: body ? { "Content-Type": "application/json" } : undefined,
          body: body ? JSON.stringify(body) : undefined,
        });
        const txt = await res.text();
        if (!res.ok) throw new Error(txt);
        return txt;
      }
      function repo() {
        return document.getElementById("repo").value;
      }

      async function listSessions() {
        document.getElementById("sessions").textContent = await api(
          `/api/sessions?repo=${encodeURIComponent(repo())}`,
        );
      }
      async function newSession() {
        const title = document.getElementById("title").value || "untitled";
        document.getElementById("sessions").textContent = await api(
          "/api/sessions/new",
          { repo: repo(), title },
        );
      }
      async function showDiff() {
        const id = document.getElementById("sessionId").value.trim();
        if (!id) return;
        document.getElementById("diff").textContent = await api(
          `/api/sessions/${encodeURIComponent(id)}/diff?repo=${encodeURIComponent(repo())}`,
        );
      }
      function downloadDiff() {
        const id = document.getElementById("sessionId").value.trim();
        if (!id) return;
        const url = `/api/sessions/${encodeURIComponent(id)}/diff/download?repo=${encodeURIComponent(repo())}`;
        window.location.href = url;
      }
      async function applyPatch() {
        const patch = document.getElementById("patch").value;
        const threeWay = document.getElementById("threeWay").checked;
        const sessionId = document.getElementById("applySessionId").value.trim();
        const body = { repo: repo(), patch, three_way: threeWay };
        if (sessionId) body.session_id = sessionId;
        try {
          const res = await fetch("/api/patch/apply.json", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body),
          });
          if (!res.ok) {
            const errorText = await res.text();
            let summary = errorText.split("\n")[0];
            try {
              const parsed = JSON.parse(errorText);
              summary = parsed.message || parsed.error_kind || summary;
            } catch (err) {
              // ignore JSON parse errors
            }
            setApplyStatus(`❌ Patch fehlgeschlagen: ${summary}`, "error");
            document.getElementById("applyOut").textContent = errorText;
            return;
          }
          const contentType = res.headers.get("Content-Type") || "";
          if (!contentType.includes("application/json")) {
            const errorText = await res.text();
            const [summary, ...rest] = errorText.split("\n");
            setApplyStatus(`❌ Patch fehlgeschlagen: ${summary}`, "error");
            document.getElementById("applyOut").textContent = rest.join("\n").trim();
            return;
          }
          const data = await res.json();
          const status = formatApplyStatus(data);
          setApplyStatus(status.text, status.state);
          document.getElementById("applyOut").textContent = data.stdout || "";
        } catch (error) {
          setApplyStatus(`❌ Patch fehlgeschlagen: ${error.message}`, "error");
          document.getElementById("applyOut").textContent = "";
          return;
        }
      }
      async function createBranch() {
        const name = document.getElementById("branch").value.trim();
        document.getElementById("gitOut").textContent = await api(
          "/api/git/branch",
          { repo: repo(), name },
        );
      }
      async function gitStatus() {
        document.getElementById("gitOut").textContent = await api(
          `/api/git/status?repo=${encodeURIComponent(repo())}`,
        );
      }
      async function gitDiff() {
        document.getElementById("gitOut").textContent = await api(
          `/api/git/diff?repo=${encodeURIComponent(repo())}`,
        );
      }
      async function gitCommit() {
        const message = document.getElementById("msg").value.trim();
        document.getElementById("gitOut").textContent = await api(
          "/api/git/commit",
          { repo: repo(), message },
        );
      }
      async function gitPush() {
        document.getElementById("gitOut").textContent = await api(
          "/api/git/push",
          { repo: repo() },
        );
      }
      async function gitPreparePr() {
        document.getElementById("gitOut").textContent = await api(
          `/api/git/pr-prepare?repo=${encodeURIComponent(repo())}`,
        );
      }
      function copyToClipboard(id) {
        const text = document.getElementById(id).textContent;
        navigator.clipboard.writeText(text);
      }
      function setApplyStatus(text, state) {
        const status = document.getElementById("applyStatus");
        status.textContent = text;
        status.className = `status ${state || ""}`.trim();
      }
      function formatApplyStatus(data) {
        const filesChanged = data?.files?.length;
        if (data.ok && data.changed) {
          const suffix = filesChanged ? ` (${filesChanged} Dateien im Patch)` : "";
          return { text: `✔ Patch angewendet${suffix}.`, state: "success" };
        }
        if (data.ok && !data.changed) {
          return { text: "⚠ Patch angewendet, aber keine Änderungen.", state: "warn" };
        }
        const summary = (data.message || "Unbekannter Fehler").split("\n")[0];
        return { text: `❌ Patch fehlgeschlagen: ${summary}`, state: "error" };
      }

      let publishJobId = null;
      let publishPoll = null;
      let publishData = null;

      async function publish() {
        const payload = { repo: repo() };
        const branchName = document.getElementById("branch").value.trim();
        const commitMessage = document.getElementById("msg").value.trim();
        const prTitle = document.getElementById("prTitle").value.trim();
        const prBody = document.getElementById("prBody").value.trim();
        const prBase = document.getElementById("prBase").value.trim();
        const prDraft = document.getElementById("prDraft").checked;
        const includeDiffstat = document.getElementById("includeDiffstat").checked;
        if (branchName) payload.branch = branchName;
        if (commitMessage) payload.commit_message = commitMessage;
        if (prTitle) payload.pr_title = prTitle;
        if (prBody) payload.pr_body = prBody;
        if (prBase) payload.base = prBase;
        payload.draft = prDraft;
        payload.include_diffstat = includeDiffstat;
        setPublishStatus("Publish gestartet…", "warn");
        document.getElementById("publishPrUrl").textContent = "";
        document.getElementById("publishOut").textContent = "";
        document.getElementById("publishDownload").disabled = true;
        try {
          const res = await fetch("/api/git/publish", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          let data = null;
          let errorText = "";
          const contentType = res.headers.get("Content-Type") || "";
          if (contentType.includes("application/json")) {
            try {
              data = await res.json();
            } catch (err) {
              errorText = await res.text();
            }
          } else {
            errorText = await res.text();
          }
          if (!res.ok) {
            const message = data?.detail || errorText || "Publish failed";
            throw new Error(message);
          }
          if (!data) {
            throw new Error("Publish failed: invalid response");
          }
          publishJobId = data.job_id;
          publishData = null;
          setPublishStatus(`Job queued (${data.job_id})`, "warn");
          startPublishPolling();
        } catch (error) {
          setPublishStatus(`❌ Publish fehlgeschlagen: ${error.message}`, "error");
        }
      }

      function startPublishPolling() {
        if (publishPoll) {
          clearInterval(publishPoll);
        }
        publishPoll = setInterval(async () => {
          if (!publishJobId) return;
          try {
            const res = await fetch(`/api/jobs/${publishJobId}`);
            let data = null;
            let errorText = "";
            const contentType = res.headers.get("Content-Type") || "";
            if (contentType.includes("application/json")) {
              try {
                data = await res.json();
              } catch (err) {
                errorText = await res.text();
              }
            } else {
              errorText = await res.text();
            }
            if (!res.ok) {
              const message = data?.detail || errorText || "Job failed";
              throw new Error(message);
            }
            if (!data) {
              throw new Error("Job failed: invalid response");
            }
            publishData = data;
            renderPublishJob(data);
            if (data.status === "done" || data.status === "error") {
              clearInterval(publishPoll);
              publishPoll = null;
            }
          } catch (error) {
            setPublishStatus(`⚠️ Publish polling failed: ${error.message}`, "warn");
          }
        }, 2000);
      }

      function renderPublishJob(data) {
        const statusMap = {
          queued: { text: "Publish queued", state: "warn" },
          running: { text: "Publish läuft…", state: "warn" },
          done: { text: "Publish abgeschlossen", state: "success" },
          error: { text: "Publish fehlgeschlagen", state: "error" },
        };
        const status = statusMap[data.status] || { text: data.status, state: "warn" };
        setPublishStatus(status.text, status.state);
        const results = data.results || [];
        const prUrl = results.find((res) => res.pr_url)?.pr_url;
        if (prUrl) {
          document.getElementById("publishPrUrl").innerHTML = `<a href="${prUrl}" target="_blank">${prUrl}</a>`;
        }
        document.getElementById("publishOut").textContent = formatPublishResults(results, data.log_tail);
        document.getElementById("publishDownload").disabled = !results.length;
      }

      function formatPublishResults(results, logTail) {
        const parts = results.map((res) => {
          const header = `${res.ok ? "✔" : "❌"} ${res.action}`;
          const summary = res.message || "";
          const error = res.error_kind ? `error_kind=${res.error_kind}` : "";
          const stdout = truncateOutput(res.stdout);
          const stderr = truncateOutput(res.stderr);
          const block = [];
          if (summary) block.push(summary);
          if (error) block.push(error);
          if (stdout) block.push(`stdout:\n${stdout}`);
          if (stderr) block.push(`stderr:\n${stderr}`);
          return [header, ...block].join("\n");
        });
        if (logTail) {
          parts.push(`\nLog tail:\n${logTail}`);
        }
        return parts.join("\n\n");
      }

      function truncateOutput(text) {
        if (!text) return "";
        const max = 2000;
        if (text.length <= max) return text;
        return `${text.slice(0, max)}\n… (truncated)`;
      }

      function downloadPublishLog() {
        if (!publishData) return;
        const blob = new Blob([JSON.stringify(publishData, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `acs-publish-${publishJobId || "log"}.json`;
        a.click();
        URL.revokeObjectURL(url);
      }

      function setPublishStatus(text, state) {
        const status = document.getElementById("publishStatus");
        status.textContent = text;
        status.className = `status ${state || ""}`.trim();
      }
    </script>
  </body>
</html>
