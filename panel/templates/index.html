<!doctype html>
<html lang="de">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>agent-control-surface</title>
    <style>
      :root {
        color-scheme: light dark;
      }
      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        margin: 16px;
        line-height: 1.4;
      }
      h1 {
        margin-bottom: 8px;
      }
      label {
        font-weight: 600;
      }
      .row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-bottom: 8px;
      }
      button {
        padding: 10px 14px;
        font-size: 16px;
      }
      input,
      select,
      textarea {
        padding: 10px;
        font-size: 16px;
      }
      textarea {
        width: 100%;
        min-height: 220px;
      }
      pre {
        white-space: pre-wrap;
        word-break: break-word;
        padding: 12px;
        background: #f3f3f3;
        border-radius: 6px;
        max-height: 360px;
        overflow: auto;
      }
      .section {
        margin-top: 24px;
      }
      .small {
        font-size: 14px;
        opacity: 0.8;
      }
      .status {
        font-weight: 600;
        margin-top: 8px;
      }
      .status.success {
        color: #2e7d32;
      }
      .status.warn {
        color: #b36b00;
      }
      .status.error {
        color: #c62828;
      }
    </style>
  </head>
  <body>
    <h1>agent-control-surface</h1>
    <p class="small">Local-only Control Surface for Jules & Git.</p>

    <label for="repo">Repo</label>
    <select id="repo">
      {% for repo in repos %}
      <option value="{{ repo.key }}">{{ repo.display }}</option>
      {% endfor %}
    </select>

    <section class="section">
      <h2>Sessions</h2>
      <div class="row">
        <input id="title" placeholder="New session title" style="min-width: 260px" />
        <button onclick="newSession()">New session</button>
        <button onclick="listSessions()">List sessions</button>
      </div>
      <pre id="sessions"></pre>
    </section>

    <section class="section">
      <h2>Diff</h2>
      <div class="row">
        <input id="sessionId" placeholder="Session ID" style="min-width: 260px" />
        <button onclick="showDiff()">Show diff</button>
        <button onclick="copyToClipboard('diff')">Copy diff</button>
        <button onclick="downloadDiff()">Download diff</button>
      </div>
      <pre id="diff"></pre>
    </section>

    <section class="section">
      <h2>Apply patch (aus ChatGPT)</h2>
      <textarea id="patch" placeholder="Paste patch here..."></textarea>
      <div class="row">
        <label>
          <input type="checkbox" id="threeWay" />
          Apply mit --3way (toleranter, kann Merges erzeugen)
        </label>
      </div>
      <div class="row">
        <input id="applySessionId" placeholder="Jules Session ID (optional)" style="min-width: 260px" />
      </div>
      <div class="row">
        <button onclick="applyPatch()">Apply patch</button>
      </div>
      <div id="applyStatus" class="status"></div>
      <pre id="applyOut"></pre>
    </section>

    <section class="section">
      <h2>PR Wizard (Git)</h2>
      <div class="row">
        <input id="branch" placeholder="branch name (z.B. jules/session-xyz)" style="min-width: 260px" />
        <button onclick="createBranch()">Create branch</button>
        <button onclick="gitStatus()">Status</button>
        <button onclick="gitDiff()">Diff</button>
      </div>
      <div class="row">
        <input id="msg" placeholder="commit message" style="min-width: 360px" />
        <button onclick="gitCommit()">Commit</button>
        <button onclick="gitPush()">Push</button>
        <button onclick="gitPreparePr()">Prepare PR</button>
      </div>
      <pre id="gitOut"></pre>
    </section>

    <script>
      async function api(path, body) {
        const res = await fetch(path, {
          method: body ? "POST" : "GET",
          headers: body ? { "Content-Type": "application/json" } : undefined,
          body: body ? JSON.stringify(body) : undefined,
        });
        const txt = await res.text();
        if (!res.ok) throw new Error(txt);
        return txt;
      }
      function repo() {
        return document.getElementById("repo").value;
      }

      async function listSessions() {
        document.getElementById("sessions").textContent = await api(
          `/api/sessions?repo=${encodeURIComponent(repo())}`,
        );
      }
      async function newSession() {
        const title = document.getElementById("title").value || "untitled";
        document.getElementById("sessions").textContent = await api(
          "/api/sessions/new",
          { repo: repo(), title },
        );
      }
      async function showDiff() {
        const id = document.getElementById("sessionId").value.trim();
        if (!id) return;
        document.getElementById("diff").textContent = await api(
          `/api/sessions/${encodeURIComponent(id)}/diff?repo=${encodeURIComponent(repo())}`,
        );
      }
      function downloadDiff() {
        const id = document.getElementById("sessionId").value.trim();
        if (!id) return;
        const url = `/api/sessions/${encodeURIComponent(id)}/diff/download?repo=${encodeURIComponent(repo())}`;
        window.location.href = url;
      }
      async function applyPatch() {
        const patch = document.getElementById("patch").value;
        const threeWay = document.getElementById("threeWay").checked;
        const sessionId = document.getElementById("applySessionId").value.trim();
        const body = { repo: repo(), patch, three_way: threeWay };
        if (sessionId) body.session_id = sessionId;
        try {
          const res = await fetch("/api/patch/apply?response_format=json", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body),
          });
          if (!res.ok) {
            const errorText = await res.text();
            const [summary, ...rest] = errorText.split("\n");
            setApplyStatus(`❌ Patch fehlgeschlagen: ${summary}`, "error");
            document.getElementById("applyOut").textContent = rest.join("\n").trim();
            return;
          }
          const contentType = res.headers.get("Content-Type") || "";
          if (!contentType.includes("application/json")) {
            const errorText = await res.text();
            const [summary, ...rest] = errorText.split("\n");
            setApplyStatus(`❌ Patch fehlgeschlagen: ${summary}`, "error");
            document.getElementById("applyOut").textContent = rest.join("\n").trim();
            return;
          }
          const data = await res.json();
          const status = formatApplyStatus(data);
          setApplyStatus(status.text, status.state);
          document.getElementById("applyOut").textContent = data.details || "";
        } catch (error) {
          setApplyStatus(`❌ Patch fehlgeschlagen: ${error.message}`, "error");
          document.getElementById("applyOut").textContent = "";
          return;
        }
      }
      async function createBranch() {
        const name = document.getElementById("branch").value.trim();
        document.getElementById("gitOut").textContent = await api(
          "/api/git/branch",
          { repo: repo(), name },
        );
      }
      async function gitStatus() {
        document.getElementById("gitOut").textContent = await api(
          `/api/git/status?repo=${encodeURIComponent(repo())}`,
        );
      }
      async function gitDiff() {
        document.getElementById("gitOut").textContent = await api(
          `/api/git/diff?repo=${encodeURIComponent(repo())}`,
        );
      }
      async function gitCommit() {
        const message = document.getElementById("msg").value.trim();
        document.getElementById("gitOut").textContent = await api(
          "/api/git/commit",
          { repo: repo(), message },
        );
      }
      async function gitPush() {
        document.getElementById("gitOut").textContent = await api(
          "/api/git/push",
          { repo: repo() },
        );
      }
      async function gitPreparePr() {
        document.getElementById("gitOut").textContent = await api(
          `/api/git/pr-prepare?repo=${encodeURIComponent(repo())}`,
        );
      }
      function copyToClipboard(id) {
        const text = document.getElementById(id).textContent;
        navigator.clipboard.writeText(text);
      }
      function setApplyStatus(text, state) {
        const status = document.getElementById("applyStatus");
        status.textContent = text;
        status.className = `status ${state || ""}`.trim();
      }
      function formatApplyStatus(data) {
        const filesChanged = data?.meta?.files_in_patch;
        if (data.ok && data.changed) {
          const suffix = filesChanged ? ` (${filesChanged} Dateien im Patch)` : "";
          return { text: `✔ Patch angewendet${suffix}.`, state: "success" };
        }
        if (data.ok && !data.changed) {
          return { text: "⚠ Patch angewendet, aber keine Änderungen.", state: "warn" };
        }
        const summary = (data.details || "Unbekannter Fehler").split("\n")[0];
        return { text: `❌ Patch fehlgeschlagen: ${summary}`, state: "error" };
      }
    </script>
  </body>
</html>
